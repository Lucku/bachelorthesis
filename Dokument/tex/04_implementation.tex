
\chapter{Implementierung}

Bevor konkrete Untersuchungen zu den Leistungsmerkmalen von Intels Technologie ausgewertet werden können, ist es nötig, einen Überblick über deren Einsatz aus Sicht einer Anwendung zu verstehen. In diesem Kapitel wird \ac{SGX} daher aus Sicht eines Entwicklers untersucht. Das Ziel ist es, einen Gesamtüberblick über die Konzepte zu vermitteln, welche zur Implementierung einer vollständigen Anwendung zum Einsatz kommen, sowie detaillierter auf die auftretenden Besonderheiten einzugehen.

Im ersten Teil des Kapitels werden das Modell und zentrale Begriffe, welche in der Umsetzung von entsprechenden Anwendungen vorzufinden sind, auf einer abstrakten Ebene eingeführt. Bevor konkrete Erklärungen in Bezug auf die Vorgehensweise erfolgen, werden daraufhin zunächst die technischen Voraussetzungen zur Benutzung der Technologie erklärt. Im Folgenden wird die Entwicklung einer Enclave untersucht, wobei die zuvor eingeführten Konzepte auf der konkreten Anwendungsebene aufgegriffen werden. Hierbei steht auch im Vordergrund, wie der Sicherheitsaspekt sowohl durch \ac{SGX} selbst, als auch durch den Entwickler beeinflusst wird. Um den Überblick über die Programmierung zu vervollständigen, ist es wichtig, auch die Limitierungen zu kennen, welche in diesem Zusammenhang auftreten. Dies ist Bestandteil des letzten Abschnitts, welcher sich dazu zum einen in die Erläuterung allgemeiner funktionaler Einschränkungen und die Schilderung eigener Erfahrungen aus einem Systemtest unterteilt. In einem Fazit wird das Kapitel abschließend zusammengefasst.

\section{Grundlegendes Programmiermodell}

Das zentrale Konzept der Anwendungsentwicklung unter Intel \ac{SGX} stellen die Enclaves dar. Wie bereits im zweiten Kapitel erklärt, dienen diese als sichere Container von Code und Daten. Sie werden in den Enclave Page Cache geladen, um einem herkömmlichen Prozess zur Verfügung zu stehen. Auch aus Sicht des Programmierers sind Enclaves unabhängig betrachtete Komponenten. Auf höherer Ebene handelt es sich um dynamische Programmbibliotheken (\acp{DLL} unter Windows,  \acp{SO} unter Linux), welche Funktionen sowie innere Datenstrukturen beinhalten. Die innerhalb einer Anwendung durch jene Bibliotheken abgebildete Teilmenge wird aus Sicht der Anwendungsarchitektur als \ac{tRTS} bezeichnet. Die dynamische Einbindung der Enclaves erfolgt durch eine gewöhnliche Anwendung. Sie bildet das \ac{uRTS} und gilt in diesem Kontext als nicht vertrauenswürdig \cite{WinGuide}. Nach dem Laden einer Enclave steht ihm deren Funktionalität zur Verfügung. Folglich ist das Programmiermodell sehr ähnlich zur üblichen Anwendungsentwicklung unter Nutzung von Bibliotheken. Im Folgenden ist mit (\ac{SGX}) Anwendung stets der jeweilige Zusammenschluss vom \ac{uRTS} und \ac{tRTS} gemeint, da es sich aus logischer Sicht um eine einzelne Anwendung handelt.

Nach dem Initialisierungsvorgang einer Enclave ist dafür gesorgt, dass ihr Speicher gegen direkte äußere Zugriffe ausgehend von privilegierten Prozessen sowie der einbindenden Anwendung geschützt ist. Der Kontrollfluss kann die Enclave nur durch genau definierte Schnittstellen passieren. Daraus folgt, dass es die Aufgabe des Programmierers ist, eine Aufteilung von Funktionalität zwischen \ac{uRTS} und \ac{tRTS} vorzunehmen. Hierzu müssen kritische Sektionen und Daten identifiziert sowie in die vertrauliche Bibliothek ausgelagert werden. Jede zusätzliche Erweiterung der Enclave sorgt hingegen für eine Vergrößerung der \ac{TCB}, wodurch in der Regel die Chancen für mögliche Sicherheitslücken erhöht werden. Es empfiehlt sich daher, eine minimale Teilmenge an Code zu finden, welcher im sicheren Umfeld ausgeführt wird.

\begin{figure}
	\includegraphics[width=0.8\linewidth]{img/SGXControlFlow.pdf}
	\centering
	\caption{Kontrollfluss zwischen Anwendung und Enclave}
	\label{fig:sgxcontrolflow}
\end{figure}

In Abbildung \ref{fig:sgxcontrolflow} ist ein Schema über den Kontrollfluss in einer SGX Anwendung zu sehen. Auf der linken Seite befindet sich das uRTS und der in ihm enthaltene, nicht vertrauenswürdige Code (untrusted) Code. Auf der rechten Seite ist die exemplarisch durch eine Enclave dargestellte tRTS inklusive dem vertrauenswürdigen (trusted) Code zu sehen. Die Programmierschnittstelle zwischen der unsicheren und sicheren Domäne ist durch zwei Arten von Funktionsaufrufen gegeben:

\paragraph{\ac{ECall}} Der Aufruf einer Funktion innerhalb der Enclave durch die unsichere Anwendung.

\paragraph{\ac{OCall}} Ausgehend von der Enclave erfolgt ein Funktionsaufruf in der unsicheren Anwendung.

\paragraph{} 
Genauer betrachtet geht der Kontrollfluss, sobald ein \ac{ECall} durch die unsichere Anwendung eingeleitet wird, zunächst durch eine sogenannte \textit{Edge Routine} auf ihrer eigenen Seite. Von dort aus wird eine zugehörige Edge Routine der Enclave aufgerufen, bevor der eigentliche Funktionsaufruf vonstatten geht. Analog verhält sich der Ablauf bei einem \ac{OCall} der Enclave an das \ac{uRTS}. Allgemein bilden die Edge Routines eine zusätzliche Sicherungsschicht für ein- und ausgehende Daten. Sie übernehmen Überprüfungen, ob übergebene Datenbuffer korrekt im Speicher referenziert sind und frei von Überläufen sind, welche schlimmstenfalls gesicherte Daten gefährden könnten. Auf ihre genaue Funktionalität wird später genauer eingegangen.

Die Festlegung, welche Funktionen nach welchem Schema aufgerufen werden dürfen, erfolgt von Seiten der Enclave. Alle für einen \ac{ECall} zulässigen Funktionen sind entsprechend in ihr implementiert, jene als \ac{OCall} angegebene müssen durch das \ac{uRTS} zur Verfügung gestellt werden. Wie später erklärt wird, sind gewisse Operationen wie die Synchronisation von Threads nicht aus einer Enclave heraus möglich und müssen in unsicherer Umgebung erfolgen.

\section{Voraussetzungen zur Benutzung}

Nachfolgend werden die Anforderungen beschrieben, welche erfüllt sein müssen, um Intel \ac{SGX} einerseits auf einem System benutzen zu können und anderseits in der Lage zu sein, entsprechende Anwendungen zu entwickeln.

Intels Prozessorerweiterungen \ac{SGX} wurden mit der 6. Generation von Intel Core Prozessoren eingeführt und setzen einen Intel Prozessor ab jener Generation zwingend voraus, um die Technologie einsetzen zu können. Sollte die entsprechende Hardware nicht vorhanden sein, bietet Intel einen Simulator an, welcher das gewünschte Verhalten in einer Softwareumgebung ausführt. Dieser ist lediglich zu Zwecken von Tests geeignet und ersetzt keineswegs das Verhalten des \ac{tRTS} im produktiven Einsatz. Die weitere Bedingung ist, dass die \ac{SGX} Funktionen innerhalb des Betriebssystems aktiviert sein müssen. Hierzu muss eine entsprechende Einstellung im \ac{BIOS} vorhanden sein, welches es erlaubt, die Benutzung entweder dauerhaft zu aktivieren oder einer ausgeführten \ac{SGX} Anwendung die Aktivierung zu überlassen \textit{(Software Enabled)}. Im Allgemeinen ist die letztere Option empfehlenswert, da auf diese Weise nicht dauerhaft Speicher für den Prozessor reserviert wird (\ac{PRM}), wie dies bei einer vollständigen Aktivierung der Fall ist \cite{SGXDetection}. Der letzte für die reine Ausführung benötigte Bestandteil ist die Intel \ac{SGX} Platform Software. Ihre Installation beinhaltet u.a. Treiber und verschiedene Dienstprogramme, etwa für die Attestierung oder das Einbinden von Enclaves in eine Anwendung. So sind u.a. auch die Launch Enclave und der dazugehörige Dienst enthalten.

Neben den bereits genannten Kriterien bzw. Vorkehrungen zur Ausführung einer Anwendung, welche sich \ac{SGX} zu Nutzen macht, sind weitere Maßnahmen im Zuge der Entwicklung einer solchen Anwendung zu treffen. Allen voran zählt hierzu die Installation des Intel \ac{SGX} \ac{SDK}, einer Sammlung von Bibliotheken, Dokumentation, Beispielprojekten sowie Tools zur Entwicklung. Einige der enthaltenen statischen Bibliotheken sind obligatorisch und müssen in eine entsprechende Anwendung eingebunden werden. Andere bieten sinnvolle Funktionen zur Benutzung innerhalb der Enclave an. So sind etwa eine sichere Variante der C++ Standardbibliothek oder Bibliotheken für kryptographische Operationen enthalten. Nach derzeitigem Stand ist die \ac{SDK} für Systeme verfügbar, welche unter Windows oder Linux laufen. Im Falle, dass \ac{SGX} Anwendungen auf einem Windowssystem entwickelt werden sollen, ist es nötig, Visual Studio mit dem enthaltenen C++ Compiler zu nutzen oder auf Intels Compiler zurückzugreifen. Unter Linux existiert hingegen ein Plugin für die Entwicklungsumgebung \textit{Eclipse}. Neben GCC kann auf jenen Systemen ebenfalls der Intel C++ Compiler eingesetzt werden. Dieser wird ohnehin auf beiden Plattformen durch Intel empfohlen \cite{WinDev}.

\section{Entwicklung einer Enclave}

Nachdem das Programmiermodell und die Voraussetzungen zur Nutzung erklärt wurden, steht nun die konkrete Anwendungsentwicklung unter \ac{SGX} im Vordergrund. Intel bietet komfortable Werkzeuge an, um dies unter C++ zu ermöglichen und zu erleichtern. Zudem können bestehende Anwendungen mit wenig Aufwand um die sichere Umgebung erweitert werden. In diesem Abschnitt sollen die einzelnen Aspekte der Definition und Implementierung einer Enclave beleuchtet werden. Dabei wird voranging auf die zu verwendenden Tools sowie auf Vorgehensweisen zur Entwicklung eingegangen. Es wird kein Augenmerk auf die reine Programmierung gelegt, sondern eher, wie sich jener Aspekt von der herkömmlichen Praxis unterscheidet.

\subsection{Definition der Enclave}

Der Aufbau eines Projektes zur Entwicklung einer Enclave unterscheidet sich grundsätzlich nicht von jenem einer üblichen C++ Bibliothek. Jedoch gibt es eine Besonderheit, die im Folgenden genauer betrachtet werden soll. Eine einzelne Datei stellt den Kern der Anwendung dar. Im allgemeinen handelt es sich hierbei um eine Deklaration der Funktionen, welche von der Enclave nach außen hin verfügbar gemacht werden (\acp{ECall}) und jene, welche die Enclave von außerhalb, also von der einbindenden Anwendung gebrauchen will (\acp{OCall}). Das hierbei von Intel verwendete Format wird als \ac{EDL} bezeichnet und besitzt eine einfache Syntax, deren Hauptbestandteil die Definition erweiterter Signaturen von C-Funktionen darstellt. Es gibt daher eine gewisse Ähnlichkeit zu einer gewöhnlichen Headerdatei, wie sie aus dem Umfeld der C/++ Programmierung bekannt ist. Im Vergleich gibt es jedoch einige erweiterte Möglichkeiten, welche im eingesetzten Kontext Sinn ergeben.

Eine Besonderheit ist etwa, dass Funktionen, welche von der Enclave nach außen hin freigegeben werden sollen, explizit durch Angabe des Schlüsselwortes \textit{public} als solche gekennzeichnet werden müssen. In diesem Fall handelt es sich um sogenannte \textit{Root \acp{ECall}}. Andernfalls sind sie privat und nur durch andere innere Funktionen oder \acp{OCall} aufrufbar. Da auch ein \ac{OCall} Gebrauch von einem \ac{ECall} der gleichen Enclavedefinition machen kann, müssen der Funktionssignatur eines \ac{OCall} alle von ihm benutzbaren sicheren Funktionen nachgestellt werden. Eine weiteres Element der Enclave Definition Language ist das Versehen von gewissen Funktionsargumenten mit Attributen. Darauf wird später genauer eingegangen. Genau wie in einer Headerdatei können mithilfe von Importanweisungen andere gleichartige Dateien eingebunden werden \cite{WinDev}. Dies ist etwa nötig, falls eine sichere Bibliothek genutzt werden soll, um den Umfang der aktuell definierten Enclave zu erweitern.

Genutzt wird die \ac{EDL}-Datei im Zuge des Erstellungsvorgangs der dazugehörigen Enclave. Anhand der Definitionen sorgt das in der SDK bereitgestellte Edger8r Tool (sgx\textunderscore edger8r) für die Generierung der Edge Routines aus den angegebenen Funktionsignaturen. Sowohl die Enclave als auch die unsichere Anwendung verfügen hinterher über die entsprechenden Implementierungen. \acp{ECall} und \acp{OCall} können daraufhin nur durch jene Edge Routines erfolgen, welche zu diesem Zweck jeweils eine Wrapperfunktion (Proxy) auf Seiten der Enclave und des \ac{uRTS} enthalten. Im Gegensatz zur restlichen \ac{SGX} Anwendung bestehen sie zudem rein aus C-Code. Als zusätzliche Sicherungsebene ist es die Aufgabe der Edge Routines, dass gewisse Prozeduren vor und nach dem eigentlichen Funktionsaufruf vonstattengehen. Der wichtigste Teil davon kümmert sich um das Überführen \textit{(Marshalling)} der Funktionsargumente zwischen den Grenzen. Ein Sonderfall tritt dann auf, sobald es sich bei einem Funktionsparameter um eine Zeigervariable handelt, welche üblicherweise einen längeren Datenbuffer referenziert. Dies ist gängige Praxis in der Verarbeitung von Datenmengen und bringt in diesem Kontext besondere, nachfolgend gelistete Probleme mit sich.

\begin{itemize}
	\item Da sich der Speicher einer Enclave im normalen Adressraum neben ungesicherten Seiten befindet, kann ein in einem \ac{ECall} übergebener Pointer zum Überschreiben gesicherter Seiten der ausführenden Enclave selbst führen.
	\item Die Übergabe eines Pointer über einen \ac{OCall} ist problematisch, da von außerhalb nicht auf in der Enclave befindlichen Speicher zugegriffen werden kann.
\end{itemize}

Um jene Hindernisse zu umgehen, werden durch Zeiger referenzierte Datenbuffer jeweils in die Enclave herein- sowie herauskopiert. Da es hierbei möglich ist, dass einzelne Speicherbereiche gesondert für die Ein- oder Ausgabe von Daten angedacht sind, ist es sinnvoll, den jeweiligen Datenfluss zu kennen, um die Daten in eine entsprechende Richtung zu kopieren. Es macht etwa Sinn, einen Eingabebuffer vor dem eigentlichen \ac{ECall} in die Enclave zu kopieren, jedoch nicht, ihn hinterher wieder in die unsichere Anwendung  zurück zu kopieren. Neben dem reinen Übertragen des Speicherbereichs finden zusätzlich \textit{Boundary Checks} statt. Dies sind Überprüfungen, ob sich jener Bereich auch wirklich komplett innerhalb der unsicheren oder sicheren Grenzen befindet. Durch diese Maßnahmen ist insgesamt gewährleistet, dass innerhalb der Enclave stets nur auf ihrem eigenen und außerhalb nur auf ungeschütztem Speicher gearbeitet wird.

In den Edge Routines wird jenes Verhalten automatisch für Datenbuffer bzw. korrespondierende Zeigervariablen umgesetzt. Dem Programmierer ist es lediglich überlassen, eine Kennzeichnung ihres Datenflusses in den Funktionssignaturen der Enclave Definition zu übernehmen. Die Angabe der Länge ist entsprechend auch nötig und wird in der Regel als weiterer Funktionsparameter übergeben. In Tabelle \ref{tab:sgxbuffer} ist ein Überblick über die einzelnen Optionen gegeben \cite{LinuxGuide}.

\begin{table}[h]
	\centering
	\caption{Attribute zum Umgang mit Buffern}
	\begin{tabularx}{\textwidth}{|l|X|X|}
		\hline
		& \textbf{\ac{ECall}} & \textbf{\ac{OCall}} \\
		\hline
		in & Der Buffer wird von dem \ac{uRTS} in die Enclave kopiert, wodurch Änderungen an jenem lediglich in sicherem Speicher erfolgen. & Der Buffer wird aus der Enclave in das \ac{uRTS} kopiert. Dies ist obligatorisch falls sicherer Speicher referenziert wird. \\
		\hline
		out & In der Enclave wird ein Datenbuffer alloziert und genutzt. Nach Ausführung der Funktion wird dieser in den angegebenen Ausgabebuffer kopiert. & Die Edge Routine auf Seiten der Enclave kopiert einen außerhalb angelegten Buffer in den gesicherten Speicher. \\
		\hline
		in, out & \multicolumn{2}{l|}{Eine Kombination aus dem Verhalten bei in und out.} \\
		\hline
		user\textunderscore check & \multicolumn{2}{p{0.8\textwidth}|}{Es erfolgt keine Überprüfung der Zeigervariablen durch die Proxyfunktionen. Der Nutzer ist selbst dazu angehalten, dies durchzuführen. Zudem wird die Längenangabe des Puffers nicht angegeben.} \\
		\hline
	\end{tabularx}
	\label{tab:sgxbuffer}
\end{table}

Es lässt sich schlussfolgern, dass die Gewährleistung der sicheren Ausführung von Funktionen in und aus der Enclave heraus auf Kosten von zusätzlichem Speicher- und Rechenaufwand erfolgt. Gerade innerhalb des gesicherten Speichers gilt es jedoch, Ersteren möglichst gering zu halten. Das user\textunderscore check Attribut übergibt das Vertrauen vollständig an den Entwickler. Dies hat zur Folge, dass die Leistung maßgeblich verbessert werden kann, sofern der entstandene Code genauestens validiert wird. Unter anderem müssen genaue Kenntnisse über die Größen der Buffer vorhanden sein, da bereits ein kleiner Überlauf zum Überschreiben von gesichertem Code oder Daten führen kann.

\subsection{Konfigurationsmöglichkeiten}

Neben den oben aufgeführten Möglichkeiten zur Umsetzung einer Enclave besteht die zusätzliche Möglichkeit, ihre Eigenschaften in einer dedizierten Konfigurationsdatei anzupassen. Sie liegt im \acs{XML} Format vor, wobei jede Option durch ein Element repräsentiert wird. In Tabelle \ref{tab:sgxconfig} sind die wichtigsten Anpassungsmöglichkeiten mit ihren Erklärungen gelistet. Daneben ist der jeweilige Standardwert aufgeführt, welcher verwendet wird, falls keine explizite Konfiguration genutzt wird.

\begin{table}[h]
	\centering
	\caption{Konfigurationsmöglichkeiten einer Enclave}
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Eigenschaft} & \textbf{Erklärung} & \textbf{Standardwert} \\
		\hline
		TCSNum & Anzahl der möglichen aktiven Threads in der Enclave & 1 \\
		\hline
		StackMaxSize & Die maximale Größe des Stackspeichers je Thread & 0x40000 (256 KB) \\
		\hline
		HeapMaxSize & Die maximale Größe des Heapspeichers & 0x100000 (1 MB) \\
		\hline
	\end{tabular}
	\label{tab:sgxconfig}
\end{table}

Relevant ist die Konfigurationsdatei erst nach Ausführung der Erstellung (Builds) der Enclave. Diese muss zusätzlich durch das in der \ac{SDK} mitgelieferte \ac{SGX} Sign Tool (sgx\textunderscore sign) mithilfe eines Schlüssels signiert werden, um diese in eine andere Anwendung einbinden zu können. Unter optionaler Angabe der Konfiguration wird die Bibliothek, in diesem Fall auch als \textit{Enclave Image} bezeichnet, um entsprechende Metadaten erweitert und vollständig signiert. Gleichzeitig findet auch eine Überprüfung der angegebenen Optionen statt. Im Falle fehlerhafter Angaben führt diese zu einem vorzeitigen Abbruch des Signaturvorgangs. Sobald die Enclave schlussendlich geladen wird, erfolgt eine Validierung der Signatur und ein Einlesen der Metadaten. Letzteres ist nötig, um unter anderem genug Speicher zu reservieren. Die aktuell erste Version von \ac{SGX} erfordert, dass alle Seiten zum Zeitpunkt der Enclave Initialisierung im \ac{EPC} hinzugefügt wurden. Daher ergibt sich auch die Notwendigkeit, maximale Größen für den Heap- und Stackspeicher, sowie die Anzahl zu erstellender Thread Control Structures im Vorhinein anzugeben. Mit Version 2 von \ac{SGX} plant Intel die Unterstützung dynamischer Allokation von EPC Seiten, wodurch diese Notwendigkeit entfallen könnte \cite{McKeen2016}. Das ebenfalls von Intel zur Verfügung gestellte \ac{SGX} Measurement Tool (sgx\textunderscore emmt) kann als Hilfsmittel genutzt werden, um den zur Laufzeit benötigten Speicher der Enclave zu messen \cite{WinDev}.

\subsection{Implementierungspraktiken}

Neben einer Angabe von \acp{ECall} und \acp{OCall} in der \ac{EDL}-Datei muss eine Implementierung der Funktionen getreu ihrer Signatur erfolgen. Während später die auftretenden Limitierungen für den Programmierer untersucht werden, wird zunächst noch kurz auf generelle Implementierungspraktiken eingegangen. 

Die Besonderheit in Bezug auf eine gute Implementierung besteht darin, dass die Ausführung von sicherer Funktionalität durch die unsichere Domäne, also der \ac{uRTS}, bestimmt wird. Aus dieser Tatsache ergeben sich die folgenden Anforderungen \cite{WinGuide}.

\begin{itemize}
	\item Es sollte keine Abhängigkeiten zu der Ausführungsreihenfolge von Funktionen innerhalb der Enclave geben, egal wie viele Threads beteiligt sind.
	\item Sichere Funktionen sollten jegliche Eingabeparameter verarbeiten, sowie mit jeglichen Ausgabewerten eines \ac{OCall} umgehen können.
	\item Es darf keine Annahme darüber getroffen werden, dass ein \ac{OCall} die erwartete Funktionalität erfüllt.
\end{itemize}

Ein Angreifer ist ebenso in der Lage, die Enclave mit einem von ihm speziell entwickelten Programm zu laden, um mögliche Schwachstellen zu nutzen. Grundsätzlich darf daher keinen Informationen aus der unsicheren Domäne getraut werden. Zweifelsohne ist die Relevanz nur dann gegeben, falls von vornherein sensible Daten wie Passwörter im sicheren Container abgelegt sind und schon nach dem Ladevorgang enthalten sind. Des weiteren gilt es in seltenen Fällen auch, Seitenkanalangriffe zu vermeiden. Mögliche Angriffsflächen sind vor allem \acp{OCall} zur Synchronisation von Threads. Auch hier ist es dem Entwickler überlassen, jenen Gefahren entgegenzuwirken, sollte der jeweilige Anwendungsfall dies erfordern \cite{M.2016}.

Neben den zuvor genannten Punkten in Bezug auf die Robustheit einer Enclave gilt es noch zu erwähnen, dass eine besondere Vorsicht beim Einbinden von Drittbibliotheken in die sichere Domäne erforderlich ist. Oftmals kann eine Sicherheitsanalyse in diesem Fall nur schwer getroffen werden, da die \ac{TCB} durch fremden Code erweitert wird. Es bietet sich an, stattdessen die von Intel mitgelieferten Bibliotheken zu nutzen. Diese sind einer genauen Analyse unterlaufen und decken die gängigsten, in einer Enclave üblichen Funktionalitäten, wie etwa kryptographische Operationen, ab.

\section{Grenzen der Programmierung}

Die Programmierung einer Anwendung unter der Nutzung von Intel \ac{SGX} ähnelt in großen Teilen der üblichen C++ Programmierung. Dennoch gibt es gewisse Limitationen, welche durch einen Entwickler beachtet werden müssen. Neben den offensichtlichen Aspekten, wie dem begrenzt zur Verfügung stehenden, gesicherten Speicher, beziehen sich diese aber auch auf den Umgang mit Funktionalität der Sprache selbst. 

Der erste Abschnitt befasst sich mit den Einschränkungen, welche von Intel in Bezug auf die Programmfunktionalität gewählt wurden und wodurch diese zu begründen sind. In einem eigenen Systemtest erfolgte eine genauere Untersuchung, inwiefern die Entwicklung daraus resultierend beeinflusst wird. Die Ergebnisse sind Augenmerk des zweiten Abschnitts.

\subsection{Funktionale Einschränkungen}

Ausschlaggebend hinter den gewählten Beschränkungen ist die Intention von \ac{SGX}, die Trusted Computing Base des Systems so klein wie möglich zu halten. Demzufolge muss es eine Isolation von Code geben, welcher sich nicht im Einflussbereich der jeweiligen Enclave befindet. Es handelt sich hauptsächlich um jenen im Betriebssystemkern. Aus diesem Grund verbietet Intel die Nutzung aller gebräuchlichen Bibliotheken in der Enclave, darunter als größte Kandidaten auch die C/C++ Standardbibliotheken. Als Ersatz werden im Zuge der \ac{SDK} jedoch als vertrauenswürdig bezeichnete Versionen mitgeliefert, welche keine Abhängigkeiten zum Betriebssystemkern mehr aufweisen und auf den eingeschränkten Speicherplatz angepasst sind (sgx\textunderscore tcxx). Ausgeschlossen sind u.a. Eingabe- und Ausgabefunktionen sowie jeglicher Code, welcher mit der Lokalisierung zusammenhängt. Sollen eigene Bibliotheken in die Enclave eingebunden werden, gibt es ebenfalls einige Dinge zu beachten. Zunächst muss es sich zwangsläufig um statisch gelinkte Varianten handeln. Da außerdem keine direkten Systemaufrufe erfolgen dürfen und auf die sonstigen beschränkten Bedingungen innerhalb der sicheren Umgebung geachtet werden muss, ist oftmals die Portierung einer existierenden Bibliothek für den Einsatz unter \ac{SGX} nötig. Zur Umsetzung von \acp{OCall} beinhaltet jene in der Regel auch ein gesondertes Gegenstück zur Einbindung im \ac{uRTS} \cite{LinuxGuide}.
 
Die aus der C++ Programmierung bekannten und wichtigen Sprachelemente werden weiterhin unterstützt, darunter etwa die dynamische (De-)allokation von Speicher mittels \textit{new} und \textit{delete} sowie die Definition von Klassen und deren Instanziierung als Objekte. Aufgrund der Tatsache, dass der Datenfluss durch die lediglich in C zur Verfügung stehenden Edge Routines erfolgt, ist es nicht möglich, Objekte über die Grenzen vom \ac{uRTS} und \ac{tRTS} zu übergeben. Im Falle, dass dies dennoch erforderlich ist, muss eine Serialisierung in \textit{Structs} erfolgen \cite{LinuxGuide}. Auch die anderen, durch C++ eingeführten Sprachfunktionen sind demnach nur innerhalb von Funktionsimplementierungen der Enclave einsetzbar, nicht jedoch als Teil der Funktionssignaturen im Code und der \ac{EDL}-Datei.

Während mehrere Threads problemlos die Enclave passieren dürfen, gilt entsprechend der Entkopplung vom Betriebssystem, dass diese außerhalb des \ac{tRTS} erzeugt werden müssen. Um eine Synchronisation paralleler Abläufe zu ermöglichen, ist an dieser Stelle noch erwähnenswert, dass Intel hierfür eine Sammlung von Funktionen und Objekten wie \textit{Spin Locks} und \textit{Mutexen} bereitstellt \cite{LinuxGuide}.

\subsection{Systemtest}

Um ein Bild zu erhalten, in welchem Umfang der Einsatz von \ac{SGX} zur Erstellung einer sicheren Programmkomponente genutzt werden kann, wurden die zur Verfügung stehenden Mittel getestet und evaluiert. Die Entwicklung fand unter Nutzung von Windows und dem dazugehörigen \ac{SDK} statt, da Intel diese im Allgemeinen besser unterstützt als unter Linux. Nachfolgend erfolgt eine kurze Auswertung der erhaltenen Erkenntnisse.

Eine der schwerwiegendsten Beschränkungen stellt in der Praxis die Größe des \ac{PRM} dar. Der maximal im \ac{BIOS} festzulegende Wert entspricht 128 MB. Zu beachten ist hierbei, dass es sich um einen Speicherbereich handelt, welcher zwischen jeder aktiven Enclave geteilt wird. Hierzu zählen auch die durch Intel bereitgestellten und stets eingebundenen Ableger zum Starten von Enclaves des Nutzers (Launch Enclave) und zu Zwecken der Attestierung. Es hat sich gezeigt, dass etwa 90 MB des \ac{EPC} für den Nutzer verbleiben. Natürlich schließt dies auch die Größe des Codes mit ein. Jene sollte jedoch vergleichsweise gering ausfallen. Die Konfigurationsdatei erlaubt derweil die Definition eines viel zu großen Heapspeichers von bis zu 256 MB, bevor das Tool zur Signatur einen Fehler anzeigt. Ebenso verhält es sich bei der Angabe zur Stackgröße und Anzahl Threads. In solch einem Fall kommt es erst zum Zeitpunkt des Einbindens der Enclave zu einem Scheitern. Bei einer Berechnung der Gesamtgröße ist stets zu beachten, dass die maximale Stackgröße mit der Anzahl Threads multipliziert werden muss und jede \ac{TCS} zusätzliche 16 KB an Metadaten benötigt. Die grundlegende Größe, also jegliche Thread Control Structures, Stack und Heap ausgenommen, liegt laut dem bereits erwähnten \ac{SGX} Measurement Tool bei 168 KB. Es empfiehlt sich allgemein, das Tool zur Hilfe zu nehmen, um sich die Gesamtgröße ausrechnen zu lassen und eine Überschreitung der 90 MB bzw. restlichen Größe des \ac{PRM} zu verhindern. Wird der Speicher, welcher einer Enclave zugeteilt ist, nach deren Integration zur Laufzeit durch interne Allokationen überschritten, wird eine übliche Ausnahme ausgelöst, welche den Zugriff auf eine unerlaubte Speicheradresse anklagt.

Der Aufruf von Systemfunktionen ist bei Bedarf mit einem \ac{OCall} verbunden, welcher jeweils deklariert und in der unsicheren Anwendung implementiert werden muss. In der Regel sollte sich dies allerdings auf eine wenige Standardfälle, wie die Konsolen- oder Dateiausgabe und die Synchronisation von Threads, beschränken.

Zuletzt ist positiv anzumerken, dass Intels eigene \ac{SIMD} Erweiterungen, wie beispielsweise \ac{AVX}, ohne weitere Einschränkungen eingesetzt werden konnten. Dies kommt entsprechend einer deutlich schnelleren Datenverarbeitung zugute und ist ein wichtiges Kriterium für den Einsatz vieler, daraufhin angepasster Algorithmen.

\section{Fazit}

In diesem Kapitel wurde die Implementierung einer \ac{SGX} Anwendung betrachtet und auf spezielle Charakteristika eingegangen, welche mit dieser einhergehen. Das Programmiermodell wird grundlegend durch die Trennung der unsicheren und sicheren Umgebung bestimmt. Erstere sorgt für die Einbindung einer oder mehrerer Enclave Images, dynamischer Bibliotheken, welche jeweils gesicherte Funktionen und Daten beinhalten. Daraufhin kontrolliert das \ac{uRTS} die Nutzung jener Funktionalität durch \acp{ECall}. Daneben erlauben \acp{OCall} der Enclave, Funktionen wie etwa Systemaufrufe in der unsicheren Domäne aufzurufen, um Funktionalität außerhalb der Trusted Computing Base nutzen zu können. Zusammen müssen \acp{ECall} und \acp{OCall} in einer \ac{EDL}-Datei  je Enclave spezifiziert werden, um die Generierung der Edge Routines durchzuführen, zusätzlicher Proxyfunktionen, welche zusätzliche Sicherheitsüberprüfungen vor und nach jenen Funktionsaufrufen durchführen. Diese gehen vor allem bei der Übergabe längerer Datenbuffer als Funktionsargumente auf Kosten von Leistung und Speicherplatz.

Während es Aufgabe der unsicheren Anwendung ist, die \acp{OCall} bereitzustellen, besteht ein Großteil der Enclaveentwicklung aus dem Implementieren der \acp{ECall}. Über eine Konfigurationsdatei ist es dem Entwickler darüber hinaus möglich, je Enclave individuelle Parameter in Bezug auf den zu reservierenden Speicher oder der maximalen Anzahl zugelassener Threads festzulegen. Betrachtet man die Vorgehensweise der Implementierung, so erfordert der Einsatz von \ac{SGX} in einer sicherheitskritischen Anwendung eine durchdachte Erstellung des Codes innerhalb der Enclave. Ein Programmierer muss stets bedenken, dass ihre Einbindung durch beliebige Software, auch der eines Angreifers, erfolgen kann. Die Vergegenwärtigung gewisser Programmierpraktiken ist daher von äußerster Bedeutung. Dazu kommt, dass die Limitierung des durch den Prozessor reservierten, sicheren Speicherplatzes berücksichtigt werden muss. Dies hat zur Folge, dass die innerhalb des Containers gehaltene Datenmenge stets gering genug gehalten werden muss. Die sonstigen Einschränkungen und Abweichungen von der standardmäßigen C++ Programmierung innerhalb der Enclave fallen eher gering aus.