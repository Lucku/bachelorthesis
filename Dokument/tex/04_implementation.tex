
\chapter{Implementierung}

Bevor konkrete Untersuchungen zu den Leistungsmerkmalen von Intels Technologie ausgewertet werden können, ist es nötig einen Überblick über dessen Einsatz aus Sicht einer Anwendung zu verstehen. In diesem Kapitel wird SGX daher aus Sicht eines Entwicklers untersucht. Das Ziel ist es insgesamt, einen Überblick über die Konzepte zu vermitteln, welche zur Implementierung einer vollständigen Anwendung zum Einsatz kommen, sowie detaillierter auf die auftretenden Besonderheiten einzugehen.

Im ersten Teil des Kapitels werden das Modell und zentrale Begriffe, welche in der Umsetzung von entsprechenden Anwendungen vorzufinden sind, auf einer abstrakten Ebene eingeführt. Bevor konkrete Erklärungen in Bezug auf die Vorgehensweise erfolgen, werden daraufhin zunächst die technischen Voraussetzungen zur Benutzung der Technologie erklärt. Im Folgenden wird die Entwicklung einer Enclave untersucht, wobei die zuvor eingeführten Konzepte auf der Ebene des Programmierers wiederzufinden sind. Hierbei steht auch im Vordergrund, wie der Sicherheitsaspekt sowohl durch SGX selbst, als auch durch den Entwickler beeinflusst wird. Um den Überblick über die Programmierung zu vervollständigen, ist es wichtig, auch die Limitierungen zu kennen, welche in diesem Zusammenhang auftreten. Dies ist Bestandteil des letzten Abschnitts, welcher sich dazu zum einen in die Erläuterung allgemeiner funktionaler Einschränkungen und die Schilderung eigener Erfahrungen aus einem Systemtest unterteilt. In einem Fazit wird das Kapitel abschließend zusammengefasst.

\section{Grundlegendes Programmiermodell}

Im Mittelpunkt der Anwendungsentwicklung unter Nutzung von Intel SGX stehen die Enclaves. Wie bereits im zweiten Kapitel erklärt, dienen jene als sichere Container von Code und Daten. Sie werden in den Enclave Page Cache geladen, um einem herkömmlichen Prozess zur Verfügung zu stehen. Auch aus Sicht des Programmierers sind Enclaves unabhängig betrachtete Komponenten. Auf hoher Ebene handelt es sich um dynamische Programmbibliotheken (\textit{Dynamic Link Libraries} unter Windows,  \textit{Shared Objects} unter Linux), welche Funktionen sowie innere Datenstrukturen beinhalten. Die innerhalb einer Anwendung durch jene Bibliotheken abgebildete Teilmenge wird aus Sicht der Anwendungsarchitektur als \textit{Trusted Runtime System} (tRTS) bezeichnet.

Die dynamische Einbindung der Enclaves erfolgt durch eine gewöhnliche Anwendung. Sie bildet das \textit{Untrusted Runtime System} (uRTS) und gilt in diesem Kontext als nicht vertrauenswürdig. Nach dem Laden einer Enclave steht ihr dessen Funktionalität zur Verfügung. Folglich ist das Programmiermodell sehr ähnlich zur üblichen Anwendungsentwicklung unter Nutzung von Bibliotheken. Im Folgenden ist mit (SGX) Anwendung stets der jeweilige Zusammenschluss von uRTS und tRTS gemeint, da es sich logisch gesehen um eine einzelne Anwendung handelt.

Nach dem Initialisierungsvorgang einer Enclave ist dafür gesorgt, dass ihr Speicher durch direkte äußere Zugriffe ausgehend von privilegierten Prozessen sowie der einbindenden Anwendung geschützt ist. Der Kontrollfluss kann die Enclave nur durch genau definierte Schnittstellen passieren. Daraus folgt, dass es die Aufgabe des Programmierers ist, eine Aufteilung von Funktionalität zwischen uRTS und tRTS vorzunehmen. Hierzu müssen kritische Sektionen und Daten identifiziert sowie in die vertrauliche Bibliothek ausgelagert werden. Jede zusätzliche Erweiterung der Enclave sorgt dabei für eine Vergrößerung der Trusted Computing Base, welche in der Regel die Chancen für mögliche Sicherheitslücken erhöht. Es empfiehlt sich daher, eine minimale Teilmenge an Code zu finden, welche im sicheren Umfeld ausgeführt wird. 

Der Kontrollfluss passiert die Grenzen der Enclave durch zwei Arten von Funktionsaufrufen. Sie bilden die Programmierschnittstelle zwischen der unsicheren und sicheren Domäne.

\paragraph{ECALL (Enclave Call) } Der Aufruf einer Funktion innerhalb der Enclave durch die unsichere Anwendung.

\paragraph{OCALL (Out Call)} Ausgehend von der Enclave erfolgt ein Funktionsaufruf in der unsicheren Anwendung.

\paragraph{}
Die Festlegung, welche Funktionen nach jeweiligem Schema aufgerufen werden dürfen, erfolgt von Seiten der Enclave. Alle für einen ECALL zulässigen Funktionen sind entsprechend in ihr implementiert, jene als OCALL angegebene müssen durch das uRTS zur Verfügung gestellt werden. Die möglichen Szenarien zum Einsatz eines OCALLs sind etwa die Ein- und Ausgabe von Daten über die Konsole, oder die Synchronisation von Threads. Wie später erklärt wird, sind jene Operationen nicht von innerhalb einer Enclave möglich. Ein Schema über den beschriebenen Kontrollfluss in einer SGX Anwendung ist in Abbildung \ref{fig:sgxcontrolflow} gezeigt.

\begin{figure}[h]
	\includegraphics[width=0.8\linewidth]{img/SGXControlFlow.pdf}
	\centering
	\caption{Kontrollfluss zwischen Anwendung und Enclave}
	\label{fig:sgxcontrolflow}
\end{figure}

Zwischen dem gegenseitigen Funktionsaufruf der beiden Domänen und den eigentlichen ECALLs, bzw. OCALLs existiert noch eine zusätzliche Ebene, welche passiert werden muss. Die sogenannten \textit{Edge Routines} sind in jeder der beiden Komponenten vorhanden und bilden eine Sicherungsschicht für ein- und ausgehende Daten. Allgemein überprüfen sie, ob übergebene Datenpuffer korrekt im Speicher referenziert sind und frei von Überläufen sind, welche u.a. sensible Daten offenbaren könnten. Im nachfolgenden Kapitel wird etwas genauer auf ihre Funktionalität eingegangen.

\section{Voraussetzungen zur Benutzung}

Nachfolgend werden die Anforderungen beschrieben, welche erfüllt sein müssen, um Intel SGX einerseits auf dem System benutzen zu können und anderseits in der Lage zu sein, entsprechende Anwendungen zu entwickeln.

Intels Prozessorerweiterungen SGX wurden mit der 6. Generation von Intel Core Prozessoren eingeführten und setzen schließlich einen Intel Prozessor ab jener Generation zwingend voraus, um die Technologie einsetzen zu können. Sollte die entsprechende Hardware nicht vorhanden sein, bietet Intel einen Simulator an, welcher das gewünschte Verhalten in einer Softwareumgebung ausführt. Dieser ist lediglich zu Zwecken von Tests geeignet und ersetzt keineswegs das Verhalten von echten Enclaves im produktiven Einsatz. Die weitere Bedingung ist, dass die SGX Funktionen innerhalb des Betriebssystems aktiviert sein müssen. Hierzu muss eine entsprechende Einstellung im BIOS vorhanden sein, welches es erlaubt, die Benutzung von SGX entweder dauerhaft zu aktivieren oder dies der ausgeführten SGX Anwendung zu überlassen \textit{(software enabled)}. Im Allgemeinen ist die letztere Option empfehlenswert, da im Gegensatz zur vollständigen Aktivierung nicht dauerhaft Speicher für den Prozessor reserviert wird (PRM), sondern dies nur bei Bedarf geschieht \cite{SGXDetection}. Der letzte für die reine Ausführung benötigte Bestandteil ist die Intel SGX Platform Software. Ihre Installation beinhaltet u.a. Treiber und verschiedene Dienstprogramme, etwa für die Attestierung oder das Einbinden von Enclaves in eine Anwendung. So sind auch die Launch Enclave und der dazugehörige Dienst enthalten.

Neben den bereits genannten Kriterien, bzw. Vorkehrungen zur Ausführung einer Anwendung, welche sich SGX zu Nutzen macht, sind weitere Maßnahmen im Zuge der Entwicklung einer solchen Anwendung zu treffen. Allen voran zählt hierzu die Installation der Intel SGX SDK, einer Sammlung von Bibliotheken, Dokumentation, Tools zur Entwicklung sowie Beispielprojekten. Einige der enthaltenen statischen Bibliotheken sind obligatorisch und müssen in eine entsprechende Anwendung eingebunden werden. Andere bieten sinnvolle Funktionen zur Benutzung innerhalb der Enclave an. So sind etwa eine sichere Variante der C++ Standardbibliothek oder Bibliotheken für kryptographische Operationen enthalten. Nach derzeitigem Stand ist die SDK für Systeme verfügbar, auf denen Windows oder Linux läuft. Im Falle, dass SGX Anwendungen auf einem Windows PC entwickelt werden sollen, ist es nötig, Visual Studio mit dem enthaltenen C++ Compiler zu nutzen, oder auf Intels Compiler zuzugreifen. Unter Linux existiert hingegen ein Plugin für die Entwicklungsumgebung \textit{Eclipse}. Neben GCC kann auf jenen Systemen ebenfalls der Intel C++ Compiler eingesetzt werden. Dieser wird auf beiden Plattformen durch Intel empfohlen \cite{WinDev}.

\section{Entwicklung einer Enclave}

Nachdem das Programmiermodell und die Voraussetzungen zur Nutzung erklärt wurden, steht nun die konkrete Anwendungsentwicklung unter SGX im Vordergrund. Intel bietet komfortable Werkzeuge an, um die dies unter C++ zu ermöglichen und erleichtern. Zudem können bestehende Anwendungen mit wenig Aufwand um die sichere Funktionalität erweitert werden. In diesem Abschnitt sollen die einzelnen Aspekte der Definition und Implementierung einer Enclave beleuchtet werden. Dabei wird voranging auf die zu verwendenden Tools, sowie auf Vorgehensweisen zur sicheren Entwicklung eingegangen. Die reine Programmierung soll kein Bestandteil sein, sondern eher, wie sich jener Aspekt von der herkömmlichen Praxis unterscheidet.

\subsection{Definition der Enclave}
%TODO Codeausschnitt mit Enclave Definition (?)
%TODO Andere Enclaves können durch Imports eingebunden werden
%TODO Funktionen können public und private sein
Der Aufbau eines Projektes zur Entwicklung einer Enclave unterscheidet sich grundsätzlich nicht von jenem einer üblichen C++ Bibliothek. Jedoch gibt es eine Besonderheit, die im Folgenden genauer betrachtet werden soll. Eine einzelne EDL-Datei stellt den Kern der Anwendung dar. Im allgemeinen handelt es sich hierbei um eine Deklaration der Funktionen, welche von der Enclave nach außen hin verfügbar gemacht werden (ECALLs) und jene, welche die Enclave von außerhalb, also von der einbindenden Anwendung gebrauchen will (OCALLs). Das hierbei von Intel verwendete Format wird als \textit{Enclave Definition Language} und besitzt eine einfache Syntax, deren Hauptbestandteil die Definition von erweiterten Signaturen für C-Funktionen darstellt. Genutzt wird die Datei im Zuge des Erstellungsvorgangs der dazugehörigen Enclave. Anhand der Definitionen sorgt das in der SDK bereitgestellte Edger8r Tool (sgx\textunderscore edger8r) für die Generierung der Edge Routines aus den angegebenen Funktionsignaturen. Sowohl die Enclave als auch die unsichere Anwendung verfügen hinterher über die entsprechenden Implementierungen. ECALLs und OCALLs können daraufhin nur durch jene Edge Routines erfolgen, welche zu diesem Zweck jeweils eine Wrapperfunktion (Proxy) auf Seiten der Enclave und uRTS enthalten. Im Gegensatz zur restlichen SGX Anwendung bestehen sie zudem rein aus C-Code. Folglich wird je eine C-Datei auf beiden Seiten generiert. Als zusätzliche Sicherungsebene ist es die Aufgabe der Edge Routines, dass gewisse Prozeduren vor und nach dem eigentlichen Funktionsaufruf von statten gehen. Der wichtigste Teil davon kümmert sich um das Überführen \textit{(Marshalling)} der Funktionsargumente zwischen den Grenzen. Von besonderer Wichtigkeit ist dies, falls es sich bei den Funktionsparametern um Zeigervariablen handelt, welche üblicherweise längere Datenpuffer referenzieren. Dies ist gängige Praxis in der Verarbeitung von Datenmengen und bringt in diesem Kontext besondere, nachfolgend gelistete Probleme mit sich.

\begin{itemize}
	\item Da sich der Speicher einer Enclave im normalen Adressraum neben ungesicherten Seiten befindet, kann ein in einem ECALL übergebener Pointer zum Überschreiben gesicherter Seiten der ausführenden Enclave selbst führen.
	\item Die Übergabe eines Pointer über einen OCALL ist problematisch, da von außerhalb nicht auf in der Enclave befindlichen Speicher zugegriffen werden kann.
\end{itemize}

Um jene Hindernisse zu umgehen, werden durch Zeiger referenzierte Datenpuffer jeweils in die Enclave herein- sowie herauskopiert. Da es hierbei möglich ist, dass jene Speicherbereiche speziell für die Ein- oder Ausgabe von Daten angedacht sind, ist es sinnvoll, den jeweiligen Datenfluss zu kennen, um die Daten in eine entsprechende Richtung zu kopieren. Es macht etwa Sinn, einen Eingabepuffer vor dem eigentlichen ECALL in die Enclave, jedoch nicht, ihn hinterher wieder zurück in die unsichere Anwendung zu kopieren. Neben dem reinen Übernehmen des Speicherbereichs finden zusätzlich \textit{Boundary Checks} statt, Überprüfungen, ob sich dieser auch wirklich komplett innerhalb der unsicheren oder sicheren Grenzen befindet. Durch diese Maßnahmen ist insgesamt gewährleistet, dass innerhalb der Enclave stets nur auf ihrem eigenen und außerhalb nur auf ungeschütztem Speicher gearbeitet wird.

In den Edge Routines wird jenes Verhalten automatisch für Datenpuffer, bzw. ihre Zeigervariablen umgesetzt. Dem Programmierer ist es lediglich überlassen, ihren Datenfluss in den Funktionssignaturen der Enclave Definition zu deklarieren. Die Angabe der Länge ist offensichtlich auch nötig, wird aber in der Regel als weiterer Funktionsparameter übergeben. In \ref{tab:sgxbuffer} ist ein Überblick über die einzelnen Optionen gegeben \cite{LinuxGuide}.

\begin{table}[h]
	\centering
	\begin{tabularx}{\textwidth}{|l|X|X|}
		\hline
		& \textbf{ECALL} & \textbf{OCALL} \\
		\hline
		in & Der Datenpuffer wird von der uRTS in die Enclave kopiert, wodurch Änderungen an jenem lediglich in sicherem Speicher erfolgen. & Der Datenpuffer wird aus der Enclave in die uRTS kopiert. Dies ist obligatorisch falls sicherer Speicher referenziert wird. \\
		\hline
		out & In der Enclave wird ein Datenpuffer alloziert und genutzt. Nach Ausführung der Funktion wird dieser in den angegebenen Ausgabepuffer kopiert. & Die Edge Routine auf Seiten der Enclave kopiert einen außerhalb angelegten Datenpuffer in den gesicherten Speicher. \\
		\hline
		in, out & \multicolumn{2}{l|}{Eine Kombination aus dem Verhalten bei in und out.} \\
		\hline
		user\textunderscore check & \multicolumn{2}{p{0.8\textwidth}|}{Es erfolgt keine Überprüfung der Zeigervariablen durch die Proxyfunktionen. Der Nutzer ist selbst dazu angehalten, dies durchzuführen. Zudem wird die Längenangabe des Puffers wird nicht angegeben.} \\
		\hline
	\end{tabularx}
	\caption{Attribute zum Umgang mit Datenpuffern}
	\label{tab:sgxbuffer}
\end{table}

Die Gewährleistung der sicheren Ausführung von Funktionen in und aus der Enclave erfolgt demzufolge auf Kosten von zusätzlichem Speicher- sowie Rechenaufwand. Gerade innerhalb des gesicherten Speichers gilt es, ersteres möglichst klein zu halten. Das user\textunderscore check Attribut übergibt das Vertrauen jedoch vollständig an den Entwickler. Dies hat zur Folge, dass die Leistung maßgeblich verbessert werden kann, sofern der entstandene Code genauestens validiert wird. Unter anderem müssen genaue Kenntnisse über die Größen der Puffer vorhanden sein, da bereits ein kleiner Pufferüberlauf für das Überschreiben von gesichertem Code oder Daten führen kann.

%TODO Andere Enclaves können durch Imports eingebunden werden
%TODO Funktionen können public und private sein

%\begin{lstlisting}
%enclave {
%	from "sgx_tstdc.edl" import *;
%	
%	trusted {
%		/* define ECALLs here. */
%		public void enclaveAllocateHeapMemory(int numBytes);
%		public void enclaveAllocateStackMemory();
%		[in, count=n] float *e, int n);
%	};
%	
%	untrusted {
%		/* define OCALLs here. */
%		void ocallLogProgress([in,size=len] const char* message, 
%		size_t len);
%	};
%};	
%\end{lstlisting}

\subsection{Konfigurationsmöglichkeiten}

Neben den oben aufgeführten Möglichkeiten zur Umsetzung einer Enclave besteht die zusätzliche Möglichkeit ihre Eigenschaften in einer dedizierten Konfigurationsdatei anzupassen. Sie liegt im XML Format vor, wobei jede Option durch ein Element repräsentiert wird. In Tabelle \ref{tab:sgxconfig} sind die wichtigsten Anpassungsmöglichkeiten mit ihren Erklärungen gelistet. Daneben ist der jeweilige Standardwert aufgeführt, welcher verwendet wird, falls keine explizite Konfiguration genutzt wird.

\begin{table}[h]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Eigenschaft} & \textbf{Erklärung} & \textbf{Standardwert} \\
		\hline
		TCSNum & Anzahl der möglichen aktiven Threads in der Enclave & 1 \\
		\hline
		StackMaxSize & Die maximale Größe des Stackspeichers je Thread & 256 KB \\
		\hline
		HeapMaxSize & Die maximale Größe des Heapspeichers & 1 MB \\
		\hline
	\end{tabular}
	\caption{Konfigurationsmöglichkeiten einer Enclave}
	\label{tab:sgxconfig}
\end{table}
%TODO TCS Nummer ist auch am Anfang anzugeben
Relevant ist die Konfigurationsdatei erst nach Ausführung der Erstellung (Builds) der Enclave. Diese muss zusätzlich durch das in der SDK mitgelieferte SGX Sign Tool (sgx\textunderscore sign) mithilfe eines Schlüssels signiert werden um diese in eine andere Anwendung einbinden zu können. Unter optionaler Angabe der Konfiguration wird die Bibliothek, in diesem Fall auch als \textit{Enclave Image} bezeichnet, um entsprechende Metadaten erweitert und vollständig signiert. Gleichzeitig findet auch eine Überprüfung der angegebenen Optionen statt, welches im Falle fehlerhafter Angaben zum Abbruch führt. Sobald die Enclave später geladen wird, erfolgt eine Validierung der Signatur und ein Einlesen der Metadaten. Letzteres ist nötig, um unter anderem genug Speicher für die Enclave zu reservieren. Die erste Version von SGX erfordert, dass alle Seiten zum Zeitpunkt der Enclave Initialisierung im EPC hinzugefügt wurden. Daher ergibt sich auch die Notwendigkeit, maximale Größen für den Heap- und Stackspeicher im Vorhinein anzugeben. Mit Version 2 von SGX plant Intel die Unterstützung dynamischer Allokation von EPC Seiten, wodurch diese Notwendigkeit entfallen könnte \cite{McKeen2016}. Das ebenfalls von Intel zur Verfügung gestellte SGX Measurement Tool (sgx\textunderscore emmt) genutzt werden, um den zur Laufzeit benötigten Speicher der Enclave zu messen \cite{WinDev}.

%\begin{minipage}{\textwidth}
%\lstset{basicstyle=\small}
%\lstinputlisting[language=XML]{code/PerformanceTests.config.xml}
%\end{minipage}

\subsection{Implementierungspraktiken}

Neben einer Angabe von ECALLs und OCALLs in der EDL-Datei müssen die Funktionen getreu ihrer Signatur implementiert werden. Während später auf die auftretenden Limitierungen für den Programmierer untersucht werden, wird zunächst noch kurz auf generelle Implementierungspraktiken eingegangen. 

Die Besonderheit in Bezug auf eine gute Implementierung besteht darin, dass die Ausführung von sicherer Funktionalität durch die unsichere Domäne bestimmt wird. Aus dieser Tatsache ergeben sich die folgenden Anforderungen \cite{WinGuide}.

\begin{itemize}
	\item Es sollte keine Abhängigkeiten zu der Ausführungsreihenfolge von Funktionen innerhalb der Enclave geben, egal wie viele Threads beteiligt sind.
	\item Sichere Funktionen sollten jegliche Eingabeparameter verarbeiten, sowie mit jeglichen Ausgabewerten eines OCALLs umgehen können.
	\item Es darf keine Annahme darüber getroffen werden, dass ein OCALL die erwartete Funktionalität erfüllt.
\end{itemize}

Ein Angreifer ist ebenso in der Lage, die Enclave mit einem von ihm speziell entwickelten Programm zu laden, um mögliche Schwachstellen zu nutzen. Grundsätzlich darf daher keinen Informationen aus der unsicheren Domäne getraut werden. Zweifelsohne ist die Relevanz nur dann gegeben, falls von vornherein sensible Daten wie Passwörter im sicheren Container abgelegt sind und schon nach dem Ladevorgang enthalten sind. Des weiteren gilt es in manchen Fällen auch, Seitenkanalangriffe zu vermeiden. Mögliche Angriffsflächen sind vor allem der Aufruf von OCALLs zur Ein- und Ausgabe oder der Synchronisation von Threads. Auch hier ist es dem Entwickler überlassen, jenen Gefahren entgegenzuwirken, sollte der jeweilige Anwendungsfall dies erfordern \cite{M.2016}.

Neben den zuvor genannten Punkten in Bezug auf die Robustheit einer Enclave gilt es noch zu erwähnen, dass eine besondere Vorsicht beim Einbinden von Drittbibliotheken in die sichere Domäne erforderlich ist. Oftmals kann eine Sicherheitsanalyse in diesem Fall schlecht nur schwer getroffen werden, da die TCB durch fremden Code erweitert wird. Es bietet sich von daher an, stattdessen die von Intel mitgelieferten Bibliotheken zu nutzen, welche einer genauen Analyse unterlaufen sind und die gängigsten Anwendungsszenarien in einer Enclave, wie etwa kryptographische Funktionen, abdecken. 
%TODO Outro (Wrap up)
\section{Grenzen der Programmierung}

Die Programmierung einer Anwendung unter der Nutzung von Intel SGX ähnelt in großen Teilen der üblichen C++ Programmierung. Dennoch gibt es gewisse Limitationen, welche durch einen Entwickler beachtet werden müssen. Neben den offensichtlichen Aspekten wie dem begrenzt zur Verfügung stehenden gesicherten Speicher beziehen sich diese aber auch auf den Umgang mit Funktionalität der Sprache selbst. 

Der erste Abschnitt befasst sich mit den Einschränkungen, welche von Intel in Bezug auf die Programmfunktionalität gewählt wurden und wodurch diese zu begründen sind. In einem eigenen Systemtest erfolgte eine genauere Untersuchung, inwiefern die Entwicklung daraufhin beeinflusst wird. Die Ergebnisse sind Augenmerk des zweiten Abschnitts. Vergleichsweise werden hierbei Untersuchungen ausgewertet, inwiefern die gewohnte Programmierung durch die eingeschränkte Umgebung beeinträchtigt wird.

\subsection{Funktionale Einschränkungen}

Ausschlaggebend hinter den gewählten Beschränkungen ist die Intention von SGX, die Trusted Computing Base des Systems so klein zu halten wie möglich. Demzufolge muss es eine Isolation von Code geben, welcher sich nicht im Einflussbereich der jeweiligen Enclave befindet. Es handelt sich hauptsächlich um jenen im Betriebssystemkern. Aus diesem Grund verbietet Intel die Nutzung aller gebräuchlichen Bibliotheken in der Enclave, darunter als größte Kandidaten auch die C/C++ Standardbibliotheken. Als Ersatz werden im Zuge der SDK jedoch als vertrauenswürdig bezeichnete Versionen mitgeliefert, welche keine Abhängigkeiten zum Betriebssystemkern mehr aufweisen und auf den eingeschränkten Speicherplatz achten (sgx\textunderscore tcxx). Ausgeschlossen sind u.a. Eingabe- und Ausgabefunktionen, sowie jeglicher Code, welcher mit Lokalisierung zusammenhängt. Sollen eigene Bibliotheken in die Enclave eingebunden werden, gibt es ebenfalls einige Dinge zu beachten. Zunächst muss es sich zwangsläufig um statisch gelinkte Varianten handeln. Da außerdem keine direkten Systemaufrufe erfolgen dürfen und auf die sonstigen beschränkten Bedingungen innerhalb der sicheren Umgebung geachtet werden muss, ist oftmals die Portierung einer existierenden Bibliothek für den Einsatz unter SGX nötig. Zur Umsetzung von OCALLs beinhaltet jene in der Regel auch ein Gegenstück für die uRTS.
 
Die aus der C++ Programmierung bekannten und wichtigen Sprachelemente werden weiterhin unterstützt, darunter etwa die dynamische (De-)allokation von Speicher mittels \textit{new} und \textit{delete}, sowie die Definition von Klassen und deren Instanziierung als Objekte. Aufgrund der Tatsache, dass der Datenfluss durch die lediglich in C zur Verfügung stehenden Edge Routines erfolgt, ist es nicht möglich, Objekte über die Grenzen von uRTS und tRTS zu übergeben. Im Falle, dass dies dennoch erforderlich ist, wird eine Serialisierung in \textit{Structs} empfohlen. Auch die anderen durch C++ eingeführten Sprachfunktionen sind demnach nur innerhalb von Funktionen der Enclave einsetzbar, nicht jedoch als Teil der Funktionssignaturen im Code und der EDL-Datei.

Während mehrere Threads problemlos die Enclave passieren dürfen, gilt entsprechend der Entkopplung vom Betriebssystem, dass jegliche Threads außerhalb der tRTS erzeugt werden müssen. Um eine Synchronisation paralleler Abläufe zu ermöglichen, ist an dieser Stelle noch erwähnenswert, dass Intel eine Sammlung von Funktionen und Objekten wie \textit{Spin Locks} und \textit{Mutexen} bereitstellt.

\subsection{Systemtest}

Um ein Bild zu erhalten, in welchem Umfang der Einsatz von SGX zur Erstellung einer sicheren Programmkomponente genutzt werden kann, wurden die zur Verfügung stehenden Mittel getestet und evaluiert. Nachfolgend erfolgt eine kurze Auswertung der erhaltenen Erkenntnisse.

Eine der schwerwiegendsten Beschränkungen stellt in der Praxis die Größe des PRM dar. Der maximal im BIOS festzulegende Wert entspricht 128 MB. Zu beachten ist hierbei, dass es sich außerdem um einen Speicherbereich handelt, welchen zwischen jeder aktiven Enclave geteilt wird. Hierzu zählen auch die durch Intel bereitgestellten und stets eingebundenen Enclaves zum Starten von jenen des Nutzers (Launch Enclave) und zu Zwecken der Attestierung. Am Ende hat sich gezeigt, dass etwa 90 MB des EPC für den Nutzer übrig bleiben, welche in der Konfigurationsdatei entsprechend vergeben werden können. Natürlich spielt auch die Größe des Codes eine Rolle. Diese sollte jedoch vergleichsweise gering ausfallen. Wird der Speicher, welcher einer Enclave zugeteilt ist, durch interne Allokationen überschritten, wird eine übliche Ausnahme ausgelöst, welche den Zugriff auf unerlaubten Speicher anklagt.

Der Aufruf von Systemfunktionen ist bei Bedarf mit einem OCALL verbunden, welche jeweils deklariert und in der unsicheren Anwendung implementiert werden muss. In der Regel sollte sich dies allerdings auf eine wenige Fälle beschränken, etwa wenn eine Konsolen- oder Dateiausgabe erfolgen soll oder Threads synchronisiert werden müssen.

Positiv ist anzumerken, dass Intels eigene SIMD Erweiterungen, wie beispielsweise AVX/AVX2 ohne weitere Einschränkungen unterstützt werden. Dies kommt entsprechend einer deutlich schnelleren Datenverarbeitung zugute.

\section{Fazit}

In diesem Kapitel wurde die Implementierung einer SGX Anwendung betrachtet und auf spezielle Charakteristika eingegangen, mit welchen diese einhergeht. Das Programmiermodell wird grundlegend durch die Trennung der sicheren und unsicheren Umgebung bestimmt. Erstere sorgt für die Einbindung einer oder mehrerer Enclave Images, dynamischer Bibliotheken, welche jeweils gesicherte Funktionen und Daten beinhalten. Daraufhin kontrolliert sie die Nutzung jener Funktionalität durch ECALLs. Daneben erlauben OCALLs der Enclave, Funktionen wie etwa Systemaufrufe in der unsicheren Domäne aufzurufen, um Funktionalität außerhalb der Trusted Computing Base nutzen zu können. Zusammen müssen ECALLs und OCALLs je Enclave in einer EDL-Datei spezifiziert werden, um die Generierung der Edge Routines durchzuführen, zusätzlicher Proxyfunktionen, welche zusätzliche Sicherheitsüberprüfungen vor und nach jenen Funktionsaufrufen durchführen. Diese gehen vor allem bei der Übergabe längerer Datenpuffer als Argumente auf Kosten von Leistung und Speicherplatz.

Während es Aufgabe der unsicheren Anwendung ist, die OCALLs bereitzustellen, besteht ein Großteil der Enclaveentwicklung aus dem Implementieren der ECALLs. Über eine Konfigurationsdatei ist es dem Entwickler darüber hinaus möglich, je Enclave individuelle Parameter in Bezug auf den zu reservierenden Speicher oder der maximalen Anzahl zugelassener Threads festzulegen. Betrachtet man die Vorgehensweise der Implementierung, so erfordert der Einsatz von SGX in einer sicherheitskritischen Anwendung eine durchdachte Erstellung des Codes innerhalb der Enclave. Ein Programmierer muss stets bedenken, dass die Einbindung jener durch beliebige Software, auch der eines Angreifers, erfolgen kann. Die Vergegenwärtigung gewisser Programmierpraktiken ist von äußerster Bedeutung. Dazu kommt, dass die Limitierung des durch den Prozessor reservierten, sicheren Speicherplatzes berücksichtigt werden muss. Dies hat zur Folge, dass die innerhalb des Containers gehaltene Datenmenge stets gering genug gehalten werden muss. Die sonstigen Einschränkungen und Abweichungen von der standardmäßigen C++ Programmierung innerhalb der Enclave sind eher gering.